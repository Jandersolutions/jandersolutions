[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Datacado",
    "section": "",
    "text": "Análise de Cesta de Compras: Revelando Padrões de Consumo com Python\n\n\n\nAnálise de Dados\n\n\nAnálise de Vendas\n\n\nVarejo e Atacado\n\n\n\n\n\n\n\nJanderson B Abreu\n\n\n22 de out. de 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOtimizando a Gestão de Preços no Varejo com Python: Aumente sua Lucratividade\n\n\n\nVarejo e Atacado\n\n\nCiência de Dados\n\n\nInteligência Artificial\n\n\n\n\n\n\n\nJanderson B Abreu\n\n\n22 de out. de 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\nHarlow Malloc\n\n\n21 de out. de 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\nTristan O’Malley\n\n\n18 de out. de 2024\n\n\n\n\n\n\n\n\nSem itens correspondentes"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts.\n\nTitulo h1\n\n\nTitulo h2\n\n\ntitulo h3\n\n\ntitulo h4\n\n\nparagrafo p\n\n\n\n\n\ntitulo 1\n\n\n\n\ntitulo 2"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n2"
  },
  {
    "objectID": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html",
    "href": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html",
    "title": "Análise de Cesta de Compras: Revelando Padrões de Consumo com Python",
    "section": "",
    "text": "# Análise de Cesta de Compras: Revelando Padrões de Consumo com Python"
  },
  {
    "objectID": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#introdução-decodificando-o-comportamento-do-consumidor",
    "href": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#introdução-decodificando-o-comportamento-do-consumidor",
    "title": "Análise de Cesta de Compras: Revelando Padrões de Consumo com Python",
    "section": "1. Introdução: Decodificando o Comportamento do Consumidor",
    "text": "1. Introdução: Decodificando o Comportamento do Consumidor\nA análise de cesta de compras é uma técnica poderosa utilizada por varejistas para entender as preferências dos consumidores. Esta abordagem permite que as empresas decifrem o comportamento do cliente e revelem padrões de consumo que podem ser cruciais para o sucesso no competitivo mundo do varejo. Como afirma Groceryshop (2020) , “conhecer o que os clientes compram em conjunto é essencial para maximizar a receita e aprimorar a experiência de compra”. Compreender o que os consumidores estão comprando em conjunto possibilita aos varejistas otimizar o sortimento de produtos, ajustar estratégias de precificação e criar promoções mais eficazes. A análise de cesta de compras não apenas ajuda a aumentar as vendas, mas também melhora a fidelização do cliente, já que oferece uma experiência de compra mais personalizada e alinhada com as suas necessidades.\nAssim, a análise de cesta de compras se torna uma ferramenta indispensável para qualquer varejista que deseja se destacar em um mercado cada vez mais exigente."
  },
  {
    "objectID": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#regras-de-associação-e-o-algoritmo-apriori",
    "href": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#regras-de-associação-e-o-algoritmo-apriori",
    "title": "Análise de Cesta de Compras: Revelando Padrões de Consumo com Python",
    "section": "2. Regras de Associação e o Algoritmo Apriori",
    "text": "2. Regras de Associação e o Algoritmo Apriori\n\nO que são Regras de Associação?\nAs regras de associação são uma técnica utilizada na mineração de dados para descobrir relações entre produtos comprados em conjunto. Essas regras ajudam a identificar padrões de compra que podem não ser imediatamente evidentes apenas pela análise dos dados brutos. Por exemplo, um varejista pode descobrir que quando um cliente compra pão, ele frequentemente também compra manteiga, o que pode influenciar promoções e organização de produtos na loja.\n\n\nO Algoritmo Apriori\nO algoritmo Apriori é uma das ferramentas mais populares para encontrar padrões frequentes em grandes conjuntos de dados de transações. Ele utiliza um método iterativo para identificar combinações de itens que aparecem com frequência em cestas de compras. O algoritmo é baseado no princípio de que se um item é comum em uma cesta de compras, então todos os subconjuntos de itens associados também devem ser frequentes.\n\nImplementação do Algoritmo Apriori em Python\nPara implementar o algoritmo Apriori em Python, utilizamos a biblioteca Mlxtend . Veja um exemplo prático:\n\nimport pandas as pd\nfrom mlxtend.frequent_patterns import apriori, association_rules\n\n# Exemplo de estrutura de transações (cada linha representando uma transação)\ndados = {'Leite': [1, 0, 1, 1, 0],\n         'Café': [1, 1, 1, 0, 0],\n         'Pão': [1, 0, 0, 1, 1],\n         'Queijo': [0, 1, 0, 1, 1]}\n\n# Criar DataFrame\ndf = pd.DataFrame(dados)\n\n# Gerar itemsets frequentes\nfrequent_itemsets = apriori(df, min_support=0.2, use_colnames=True)\n\n# Gerar regras de associação\nregras = association_rules(frequent_itemsets, metric=\"lift\", min_threshold=1)\n\n# Exibir regras\nprint(regras)\n\n       antecedents      consequents  antecedent support  consequent support  \\\n0          (Leite)           (Café)                 0.6                 0.6   \n1           (Café)          (Leite)                 0.6                 0.6   \n2          (Leite)            (Pão)                 0.6                 0.6   \n3            (Pão)          (Leite)                 0.6                 0.6   \n4            (Pão)         (Queijo)                 0.6                 0.6   \n5         (Queijo)            (Pão)                 0.6                 0.6   \n6      (Pão, Café)          (Leite)                 0.2                 0.6   \n7          (Leite)      (Pão, Café)                 0.6                 0.2   \n8  (Leite, Queijo)            (Pão)                 0.2                 0.6   \n9            (Pão)  (Leite, Queijo)                 0.6                 0.2   \n\n   support  confidence      lift  leverage  conviction  zhangs_metric  \n0      0.4    0.666667  1.111111      0.04         1.2           0.25  \n1      0.4    0.666667  1.111111      0.04         1.2           0.25  \n2      0.4    0.666667  1.111111      0.04         1.2           0.25  \n3      0.4    0.666667  1.111111      0.04         1.2           0.25  \n4      0.4    0.666667  1.111111      0.04         1.2           0.25  \n5      0.4    0.666667  1.111111      0.04         1.2           0.25  \n6      0.2    1.000000  1.666667      0.08         inf           0.50  \n7      0.2    0.333333  1.666667      0.08         1.2           1.00  \n8      0.2    1.000000  1.666667      0.08         inf           0.50  \n9      0.2    0.333333  1.666667      0.08         1.2           1.00  \n\n\n/home/janderscience/Projeto/site/Datacado/env/lib/python3.12/site-packages/mlxtend/frequent_patterns/fpcommon.py:109: DeprecationWarning:\n\nDataFrames with non-bool types result in worse computationalperformance and their support might be discontinued in the future.Please use a DataFrame with bool type\n\n\n\nNeste código, transformamos os dados de transações em um formato adequado para análise, aplicamos o algoritmo Apriori para encontrar conjuntos frequentes e extraímos regras de associação baseadas em uma métrica de elevação (lift)."
  },
  {
    "objectID": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#encontrando-insights-e-oportunidades-de-negócios",
    "href": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#encontrando-insights-e-oportunidades-de-negócios",
    "title": "Análise de Cesta de Compras: Revelando Padrões de Consumo com Python",
    "section": "3. Encontrando Insights e Oportunidades de Negócios",
    "text": "3. Encontrando Insights e Oportunidades de Negócios\nApós aplicar o algoritmo Apriori, a próxima etapa é analisar os resultados para identificar produtos frequentemente comprados juntos. Os insights obtidos podem ser extremamente valiosos para os varejistas. Por exemplo, ao descobrir que fraldas e cerveja são frequentemente compradas juntas, os varejistas podem criar promoções cruzadas para estimular as vendas. Além disso, esses insights podem ser usados para otimizar o layout da loja , posicionando produtos que se complementam próximos uns dos outros, facilitando a compra pelo cliente.\n\nExemplos de Aplicações Práticas\n\nPromoções Cruzadas : Compre um pacote de fraldas e leve um desconto na compra de cerveja.\nOtimização do Layout : Posicionar fraldas e produtos de higiene ao lado de itens para festas e bebidas, aumentando a probabilidade de compras impulsivas."
  },
  {
    "objectID": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#visualização-de-dados-para-melhor-compreensão",
    "href": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#visualização-de-dados-para-melhor-compreensão",
    "title": "Análise de Cesta de Compras: Revelando Padrões de Consumo com Python",
    "section": "4. Visualização de Dados para Melhor Compreensão",
    "text": "4. Visualização de Dados para Melhor Compreensão\nA visualização de dados desempenha um papel crucial na interpretação dos resultados da análise de cesta de compras. Ferramentas de visualização ajudam os varejistas a entender melhor as relações entre produtos e a comunicar esses insights de forma clara e intuitiva.\n\nUsando Bibliotecas Python para Visualização\nBibliotecas como NetworkX e Plotly permitem criar representações visuais dos dados de associação, tornando os padrões de consumo mais evidentes.\n\nExemplo de Visualização com NetworkX\n\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n# Criar um gráfico de rede\nG = nx.from_pandas_edgelist(regras, source='antecedents', target='consequents', edge_attr='lift')\n\n# Desenhar o gráfico\nplt.figure(figsize=(10, 10))\nnx.draw(G, with_labels=True, node_size=3000, node_color='skyblue', font_size=15, font_weight='bold')\nplt.title('Gráfico de Rede das Regras de Associação')\nplt.show()\n\n\n\n\n\n\n\n\nNeste exemplo, usamos o NetworkX para visualizar as regras de associação, onde cada nó representa um produto e as arestas representam a relação entre eles, ponderada pela métrica de lift. Essa visualização ajuda a identificar rapidamente quais produtos estão mais interconectados e podem ser alvo de estratégias de marketing."
  },
  {
    "objectID": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#conclusão",
    "href": "posts/Análise de Cesta de Compras: Revelando Padrões de Consumo com Python/index.html#conclusão",
    "title": "Análise de Cesta de Compras: Revelando Padrões de Consumo com Python",
    "section": "5. Conclusão",
    "text": "5. Conclusão\nA análise de cesta de compras é uma ferramenta poderosa para entender o comportamento do consumidor e otimizar as operações de varejo. Ao aplicar técnicas de regras de associação, como o algoritmo Apriori, os varejistas podem identificar padrões de compra e encontrar novas oportunidades de negócios. Os insights obtidos a partir dessa análise não só ajudam a melhorar as estratégias de marketing, mas também contribuem para uma melhor experiência do cliente, uma vez que promovem uma personalização que pode aumentar a fidelidade do consumidor. Conforme mencionado por Wang et al. (2018) , “a capacidade de interpretar dados de transações pode transformar a maneira como as empresas se conectam com seus clientes”. Portanto, investir na análise de cesta de compras deve ser uma prioridade para os varejistas que buscam não apenas aumentar as vendas, mas também construir relacionamentos mais fortes com seus clientes.\n\n\nReferências\n\nGroceryshop. (2020). The Importance of Basket Analysis in Retail. Disponível em groceryshop.com .\nWang, Y., Gunasekaran, A., & Ngai, E. W. T. (2018). Big Data in Logistics and Supply Chain Management: Future Directions and the Role of the Researcher. International Journal of Production Economics, 176, 98-110."
  },
  {
    "objectID": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html",
    "href": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html",
    "title": "Otimizando a Gestão de Preços no Varejo com Python: Aumente sua Lucratividade",
    "section": "",
    "text": "# Otimizando a Gestão de Preços no Varejo com Python: Aumente sua Lucratividade"
  },
  {
    "objectID": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#introdução",
    "href": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#introdução",
    "title": "Otimizando a Gestão de Preços no Varejo com Python: Aumente sua Lucratividade",
    "section": "1. Introdução",
    "text": "1. Introdução\nA precificação estratégica é uma das principais ferramentas que um varejista possui para influenciar as vendas e maximizar a lucratividade. No mundo do varejo e atacado, onde a concorrência é acirrada e as margens de lucro estão frequentemente sob pressão, a capacidade de ajustar os preços de forma eficaz se torna um diferencial crucial. Segundo Kotler e Keller (2016) , “o preço é um dos mais poderosos instrumentos de marketing e, quando bem utilizado, pode ser a chave para a sobrevivência e o crescimento de uma empresa”.Por outro lado, a precificação manual enfrenta desafios significativos, como a dependência de intuições ou regras de thumb que podem não refletir a realidade do mercado. A otimização de preços baseada em dados não apenas melhora a precisão na definição de preços, mas também proporciona insights sobre a elasticidade da demanda, ajudando os varejistas a maximizar suas margens. Um estudo da McKinsey mostra que empresas que implementam estratégias de precificação baseadas em dados podem ver um aumento de até 20% na lucratividade ."
  },
  {
    "objectID": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#coleta-e-preparo-de-dados-relevantes",
    "href": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#coleta-e-preparo-de-dados-relevantes",
    "title": "Otimizando a Gestão de Preços no Varejo com Python: Aumente sua Lucratividade",
    "section": "2. Coleta e Preparo de Dados Relevantes",
    "text": "2. Coleta e Preparo de Dados Relevantes\nA otimização de preços começa com a coleta de dados relevantes . Vários fatores influenciam o preço ideal de um produto, incluindo:\n\nCustos de produção\nPreços dos concorrentes\nDemanda do consumidor\nSazonalidade\nDados demográficos Essas informações podem ser coletadas de diversas fontes, como relatórios internos, pesquisas de mercado e até mesmo através de web scraping . Usar bibliotecas Python como Beautiful Soup permite que os varejistas extraíam automaticamente preços de concorrentes, oferecendo uma visão competitiva do mercado.\nExemplo de Web Scraping com Beautiful Soup\n\nAqui está um exemplo de como você pode usar o Beautiful Soup para extrair preços de um site de concorrência:\n\nimport requests\nfrom bs4 import BeautifulSoup\nimport pandas as pd\n\n# URL de exemplo de um site didático\nurl = 'https://webscraper.io/test-sites/e-commerce/allinone/computers/laptops'\n\n# Fazer a requisição HTTP\nresposta = requests.get(url)\n\n# Verificar se a requisição foi bem-sucedida (status code 200)\nif resposta.status_code == 200:\n    # Análise da página com BeautifulSoup\n    sopa = BeautifulSoup(resposta.text, 'html.parser')\n\n    # Encontrar os nomes dos produtos (tags a com a classe title)\n    produtos = sopa.find_all('a', class_='title')\n\n    # Encontrar os preços dos produtos (tags h4 com a classe correta)\n    precos = sopa.find_all('h4', class_='price')\n\n    # Encontrar as descrições dos produtos (tags p com a classe description)\n    descricoes = sopa.find_all('p', class_='description')\n\n    # Encontrar as classificações dos produtos (tags div com a classe ratings)\n    classificacoes = sopa.find_all('div', class_='ratings')\n\n    # Verificar se encontramos os dados necessários\n    if produtos and precos and descricoes and classificacoes:\n        # Preparar lista de dados\n        lista_dados = []\n        for produto, preco, descricao, classificacao in zip(produtos, precos, descricoes, classificacoes):\n            nome_produto = produto.text.strip()\n            preco_produto = preco.text.strip()\n            descricao_produto = descricao.text.strip()\n            \n            # Extrair o número de estrelas da classificação\n            estrelas = classificacao.find_all('span', class_='glyphicon glyphicon-star')\n            num_estrelas = len(estrelas)\n\n            # Extrair o número de reviews\n            num_reviews = classificacao.find('p').text.strip()\n\n            # Adicionar os dados à lista\n            lista_dados.append({\n                'produto': nome_produto,\n                'preco': preco_produto,\n                'descricao': descricao_produto,\n                'classificacao': num_estrelas,\n                'num_reviews': num_reviews\n            })\n\n        # Criar DataFrame com os dados\n        df = pd.DataFrame(lista_dados)\n\n        # Salvar os dados em um arquivo CSV\n        df.to_csv('precos_completos.csv', index=False)\n\n        print(f\"Arquivo 'precos_completos.csv' criado com sucesso!\")\n\n        # Exibir os primeiros 5 produtos para confirmação\n        print(df.head())\n\n    else:\n        print(\"Dados insuficientes encontrados.\")\nelse:\n    print(f\"Erro ao acessar a página. Status code: {resposta.status_code}\")\n\nArquivo 'precos_completos.csv' criado com sucesso!\n             produto    preco  \\\n0   Asus VivoBook...  $295.99   \n1  Prestigio Smar...     $299   \n2  Prestigio Smar...     $299   \n3      Aspire E1-510  $306.99   \n4  Lenovo V110-15...  $321.94   \n\n                                           descricao  classificacao  \\\n0  Asus VivoBook X441NA-GA190 Chocolate Black, 14...              0   \n1  Prestigio SmartBook 133S Dark Grey, 13.3\" FHD ...              0   \n2  Prestigio SmartBook 133S Gold, 13.3\" FHD IPS, ...              0   \n3    15.6\", Pentium N3520 2.16GHz, 4GB, 500GB, Linux              0   \n4  Lenovo V110-15IAP, 15.6\" HD, Celeron N3350 1.1...              0   \n\n  num_reviews  \n0  14 reviews  \n1   8 reviews  \n2  12 reviews  \n3   2 reviews  \n4   5 reviews  \n\n\nApós coletar os dados, a limpeza e manipulação são essenciais. Utilizar a biblioteca Pandas permite que você organize e prepare esses dados para a modelagem, removendo inconsistências e valores ausentes.\n\nExemplos de Limpeza de Dados com Pandas\n\nimport pandas as pd\n\n# Carregar os dados raspados\ndf = pd.read_csv('precos_completos.csv')\n\n# Verificar as colunas do DataFrame\nprint(\"Colunas disponíveis no DataFrame:\", df.columns)\n\n# Função para limpar e converter os preços\ndef limpar_preco(preco):\n    # Remover símbolo de moeda e múltiplos valores concatenados\n    preco = preco.replace('$', '')  # Remover '$'\n    preco = preco.split('$')[0]  # Caso haja múltiplos preços concatenados, pega o primeiro\n    try:\n        # Converter para float\n        return float(preco)\n    except ValueError:\n        # Caso não seja possível converter, retornar NaN\n        return pd.NA\n\n# Aplicar a função de limpeza à coluna de preços\ndf['preco'] = df['preco'].apply(limpar_preco)\n\n# Remover duplicatas com base nas colunas disponíveis\ndf = df.drop_duplicates(subset=['produto', 'descricao', 'preco', 'classificacao', 'num_reviews'])\n\n# Preencher valores ausentes de forma inteligente\ndf['preco'] = df['preco'].fillna(df['preco'].mean())\n\n# Preencher classificações ausentes com a média\nif 'classificacao' in df.columns:\n    df['classificacao'] = df['classificacao'].fillna(df['classificacao'].mean())\n\n# Preencher número de reviews ausente com 0\nif 'num_reviews' in df.columns:\n    df['num_reviews'] = df['num_reviews'].fillna(0)\n\n# Verificar o DataFrame limpo\nprint(df.head())\n\n# Salvar o DataFrame limpo\ndf.to_csv('precos_limpo.csv', index=False)\n\nColunas disponíveis no DataFrame: Index(['produto', 'preco', 'descricao', 'classificacao', 'num_reviews'], dtype='object')\n             produto   preco  \\\n0   Asus VivoBook...  295.99   \n1  Prestigio Smar...  299.00   \n2  Prestigio Smar...  299.00   \n3      Aspire E1-510  306.99   \n4  Lenovo V110-15...  321.94   \n\n                                           descricao  classificacao  \\\n0  Asus VivoBook X441NA-GA190 Chocolate Black, 14...              0   \n1  Prestigio SmartBook 133S Dark Grey, 13.3\" FHD ...              0   \n2  Prestigio SmartBook 133S Gold, 13.3\" FHD IPS, ...              0   \n3    15.6\", Pentium N3520 2.16GHz, 4GB, 500GB, Linux              0   \n4  Lenovo V110-15IAP, 15.6\" HD, Celeron N3350 1.1...              0   \n\n  num_reviews  \n0  14 reviews  \n1   8 reviews  \n2  12 reviews  \n3   2 reviews  \n4   5 reviews"
  },
  {
    "objectID": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#modelagem-de-preços-com-machine-learning",
    "href": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#modelagem-de-preços-com-machine-learning",
    "title": "Otimizando a Gestão de Preços no Varejo com Python: Aumente sua Lucratividade",
    "section": "3. Modelagem de Preços com Machine Learning",
    "text": "3. Modelagem de Preços com Machine Learning\nCom os dados prontos, é hora de aplicar algoritmos de aprendizado de máquina para construir modelos de precificação. Métodos como regressão linear , regressão polinomial e Random Forest são algumas das abordagens eficazes.\n\nExemplo de Regressão Linear\nAqui está um exemplo básico de como implementar uma regressão linear usando a biblioteca Scikit-learn :\n\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\n\n# Carregar os dados limpos\ndf = pd.read_csv('precos_limpo.csv')\n\n# Tratar valores ausentes\ndf['preco'].fillna(df['preco'].mean(), inplace=True)\n\n# Verifique se as colunas 'rating' e 'num_avaliacoes' estão presentes\nif 'rating' in df.columns:\n    df['rating'].fillna(df['rating'].mean(), inplace=True)\n\nif 'num_avaliacoes' in df.columns:\n    df['num_avaliacoes'].fillna(0, inplace=True)\nelse:\n    df['num_avaliacoes'] = 0  # Ou outra lógica que você preferir\n\n# Ajustar a seleção das variáveis independentes (X) com base nas colunas disponíveis\nX_cols = ['classificacao']  # Ajuste aqui com base nas colunas que fazem sentido\n\nX = df[X_cols]\ny = df['preco']\n\n# One-hot encoding para variáveis categóricas (por exemplo, 'classificacao')\npreprocessador = ColumnTransformer(transformers=[\n    ('cat', OneHotEncoder(), ['classificacao'])\n], remainder='passthrough')\n\n# Criar pipeline de pré-processamento e modelo\npipeline = Pipeline(steps=[\n    ('preprocess', preprocessador),\n    ('modelo', LinearRegression())\n])\n\n# Dividir em conjunto de treinamento e teste\nX_treino, X_teste, y_treino, y_teste = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Treinar o modelo\npipeline.fit(X_treino, y_treino)\n\n# Fazer previsões\nprevisoes = pipeline.predict(X_teste)\n\n# Exibir as primeiras 10 previsões e as 10 primeiras linhas do conjunto de teste\nprint(\"As primeiras 10 previsões são:\", previsoes[:10])\nprint(\"\\nAs 10 primeiras linhas do conjunto de teste:\")\nprint(X_teste.head(10))\n\nAs primeiras 10 previsões são: [912.87774194 912.87774194 912.87774194 912.87774194 912.87774194\n 912.87774194 912.87774194 912.87774194 912.87774194 912.87774194]\n\nAs 10 primeiras linhas do conjunto de teste:\n    classificacao\n44              0\n4               0\n53              0\n42              0\n10              0\n85              0\n72              0\n94              0\n36              0\n11              0\n\n\n/tmp/ipykernel_35161/881320131.py:12: FutureWarning:\n\nA value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.\nThe behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.\n\nFor example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.\n\n\n\n\n\nA comparação entre diferentes modelos pode ser feita utilizando métricas de performance como RMSE e R² , permitindo que o varejista escolha o modelo mais eficaz."
  },
  {
    "objectID": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#implementação-e-monitoramento",
    "href": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#implementação-e-monitoramento",
    "title": "Otimizando a Gestão de Preços no Varejo com Python: Aumente sua Lucratividade",
    "section": "4. Implementação e Monitoramento",
    "text": "4. Implementação e Monitoramento\nApós a criação do modelo, a próxima etapa é a implementação . Integrar os modelos de precificação com os sistemas de gestão existentes é essencial para a aplicação prática. Além disso, é fundamental monitorar continuamente o desempenho dos preços.Para isso, dashboards interativos podem ser criados usando bibliotecas como Dash ou Streamlit , permitindo que os gestores visualizem em tempo real as variações de preço e suas consequências nas vendas. Abaixo, apresentamos um exemplo básico de um dashboard em Streamlit:\n\nExemplo de Dashboard com Streamlit\nSalve como app.py e faça: streamlit run app.py no terminal e o resultado sera uma dashboard que analisa produtos em intervalo de preços\n\nimport pandas as pd\nimport streamlit as st\nimport plotly.express as px\n\n# Carregar os dados limpos\ndf = pd.read_csv('precos_limpo.csv')\n\n# Tratar valores ausentes\ndf['preco'] = df['preco'].fillna(df['preco'].mean())\n\n# Streamlit\nst.title('Dashboard de Preços')\nst.markdown('&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootswatch/4.5.2/united/bootstrap.min.css\"&gt;', unsafe_allow_html=True)\n\nst.sidebar.header('Filtros')\n\n# Filtro por faixa de preço\npreco_min, preco_max = st.sidebar.slider(\n    'Selecione a faixa de preço:',\n    min_value=float(df['preco'].min()),\n    max_value=float(df['preco'].max()),\n    value=(float(df['preco'].min()), float(df['preco'].max()))\n)\n\n# Filtrar o DataFrame\ndf_filtrado = df[\n    (df['preco'] &gt;= preco_min) & (df['preco'] &lt;= preco_max)\n]\n\n# Cards de informações\nmedia_preco = df_filtrado['preco'].mean()\npreco_maximo = df_filtrado['preco'].max()\npreco_minimo = df_filtrado['preco'].min()\n\n# Cálculos dinâmicos para custo total\ncusto_total = df_filtrado['preco'].sum()  # Custo total\n\n# Calcular somatória de preços por produto\nsoma_precos_por_produto = df_filtrado.groupby('produto')['preco'].sum().reset_index()\n\n# Identificar produto mais e menos vendido\nproduto_mais_vendido = soma_precos_por_produto.loc[soma_precos_por_produto['preco'].idxmax()]['produto'] if not soma_precos_por_produto.empty else 'N/A'\nproduto_menos_vendido = soma_precos_por_produto.loc[soma_precos_por_produto['preco'].idxmin()]['produto'] if not soma_precos_por_produto.empty else 'N/A'\n\n# Estilizando os cards\nst.markdown(\"\"\"\n    &lt;style&gt;\n    .card {\n        border-radius: 10px;\n        padding: 20px;\n        margin: 5px; /* Reduzir margem */\n        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);\n        color: white;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        height: 100px;\n        flex-grow: 1;\n    }\n    .media {background-color: #FFA500;} /* Laranja */\n    .maximo {background-color: #28a745;} /* Verde */\n    .minimo {background-color: #dc3545;} /* Vermelho */\n    .lucro {background-color: #007bff;} /* Azul */\n    .mais-vendido {background-color: #17a2b8;} /* Ciano */\n    .menos-vendido {background-color: #6f42c1;} /* Roxo */\n    &lt;/style&gt;\n\"\"\", unsafe_allow_html=True)\n\n# Layout para os cards ocupando toda a largura\ncol1, col2, col3 = st.columns([1, 1, 1])\nwith col1:\n    st.markdown(f'&lt;div class=\"card media\"&gt;Média de Preço: R$ {media_preco:.2f}&lt;/div&gt;', unsafe_allow_html=True)\nwith col2:\n    st.markdown(f'&lt;div class=\"card maximo\"&gt;Preço Mais Alto: R$ {preco_maximo:.2f} ▲&lt;/div&gt;', unsafe_allow_html=True)\nwith col3:\n    st.markdown(f'&lt;div class=\"card minimo\"&gt;Preço Mais Baixo: R$ {preco_minimo:.2f} ▼&lt;/div&gt;', unsafe_allow_html=True)\n\n# Novos cards\ncol4, col5, col6 = st.columns([1, 1, 1])\nwith col4:\n    st.markdown(f'&lt;div class=\"card lucro\"&gt;Custo Total: R$ {custo_total:.2f}&lt;/div&gt;', unsafe_allow_html=True)\nwith col5:\n    st.markdown(f'&lt;div class=\"card mais-vendido\"&gt;Produto Mais Vendido: {produto_mais_vendido}&lt;/div&gt;', unsafe_allow_html=True)\nwith col6:\n    st.markdown(f'&lt;div class=\"card menos-vendido\"&gt;Produto Menos Vendido: {produto_menos_vendido}&lt;/div&gt;', unsafe_allow_html=True)\n\n# Exibir resultados\nst.write(\"Resultados filtrados:\")\nst.dataframe(df_filtrado)\n\n# Gráficos\nst.subheader(\"Distribuição de Preços e Contagem por Classificação\")\n\n# Layout para os gráficos ocupando toda a largura\ncol7, col8 = st.columns([1, 1])\n\nwith col7:\n    st.bar_chart(df_filtrado['preco'], use_container_width=True)\nwith col8:\n    classificacao_contagem = df_filtrado['classificacao'].value_counts()\n    st.bar_chart(classificacao_contagem, use_container_width=True)\n\n# Gráfico de Boxplot\nst.subheader(\"Análise Gráfica\")\nfig_box = px.box(df_filtrado, y='preco', title='Boxplot de Preços')\nst.plotly_chart(fig_box, use_container_width=True)\nA criação de um dashboard não só facilita a visualização dos dados, mas também permite a tomada de decisões rápidas e informadas. Assim, os varejistas podem ajustar preços em tempo real com base no desempenho de vendas e na concorrência."
  },
  {
    "objectID": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#conclusão",
    "href": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#conclusão",
    "title": "Otimizando a Gestão de Preços no Varejo com Python: Aumente sua Lucratividade",
    "section": "5. Conclusão",
    "text": "5. Conclusão\nA otimização de preços baseada em dados é um caminho eficaz para aumentar a lucratividade e a competitividade no mercado. Com a combinação certa de coleta de dados, modelagem preditiva e monitoramento contínuo, os varejistas podem não apenas responder às flutuações do mercado, mas também antecipá-las. Ao implementar essas técnicas, os varejistas estão melhor posicionados para maximizar suas margens de lucro e melhorar a satisfação do cliente.Como afirma Baker (2018) , “um preço bem definido é mais do que apenas um número; é uma estratégia que pode influenciar o comportamento do consumidor e impulsionar as vendas”.\n\n\nReferências\n\nBaker, M. J. (2018). Marketing Strategy and Management. Palgrave Macmillan.\nKotler, P., & Keller, K. L. (2016). Marketing Management. Pearson.\nMcKinsey & Company. (2020). Pricing Excellence: How to Boost Profitability.\nDavenport, T. H. (2013). Analytics at Work: Smarter Decisions, Better Results. Harvard Business Review Press."
  },
  {
    "objectID": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#salve-como-app.py-e-faça-streamlit-run-app.py-no-terminal",
    "href": "posts/Otimizando a Gestão de Preços no Varejo com Python/index.html#salve-como-app.py-e-faça-streamlit-run-app.py-no-terminal",
    "title": "Otimizando a Gestão de Preços no Varejo com Python: Aumente sua Lucratividade",
    "section": "Salve como app.py e faça: streamlit run app.py no terminal",
    "text": "Salve como app.py e faça: streamlit run app.py no terminal\nimport pandas as pd\nimport streamlit as st\nimport plotly.express as px\n\n# Carregar os dados limpos\ndf = pd.read_csv('precos_limpo.csv')\n\n# Tratar valores ausentes\ndf['preco'] = df['preco'].fillna(df['preco'].mean())\n\n# Streamlit\nst.title('Dashboard de Preços')\nst.markdown('&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootswatch/4.5.2/united/bootstrap.min.css\"&gt;', unsafe_allow_html=True)\n\nst.sidebar.header('Filtros')\n\n# Filtro por faixa de preço\npreco_min, preco_max = st.sidebar.slider(\n    'Selecione a faixa de preço:',\n    min_value=float(df['preco'].min()),\n    max_value=float(df['preco'].max()),\n    value=(float(df['preco'].min()), float(df['preco'].max()))\n)\n\n# Filtrar o DataFrame\ndf_filtrado = df[\n    (df['preco'] &gt;= preco_min) & (df['preco'] &lt;= preco_max)\n]\n\n# Cards de informações\nmedia_preco = df_filtrado['preco'].mean()\npreco_maximo = df_filtrado['preco'].max()\npreco_minimo = df_filtrado['preco'].min()\n\n# Cálculos dinâmicos para custo total\ncusto_total = df_filtrado['preco'].sum()  # Custo total\n\n# Calcular somatória de preços por produto\nsoma_precos_por_produto = df_filtrado.groupby('produto')['preco'].sum().reset_index()\n\n# Identificar produto mais e menos vendido\nproduto_mais_vendido = soma_precos_por_produto.loc[soma_precos_por_produto['preco'].idxmax()]['produto'] if not soma_precos_por_produto.empty else 'N/A'\nproduto_menos_vendido = soma_precos_por_produto.loc[soma_precos_por_produto['preco'].idxmin()]['produto'] if not soma_precos_por_produto.empty else 'N/A'\n\n# Estilizando os cards\nst.markdown(\"\"\"\n    &lt;style&gt;\n    .card {\n        border-radius: 10px;\n        padding: 20px;\n        margin: 5px; /* Reduzir margem */\n        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);\n        color: white;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        height: 100px;\n        flex-grow: 1;\n    }\n    .media {background-color: #FFA500;} /* Laranja */\n    .maximo {background-color: #28a745;} /* Verde */\n    .minimo {background-color: #dc3545;} /* Vermelho */\n    .lucro {background-color: #007bff;} /* Azul */\n    .mais-vendido {background-color: #17a2b8;} /* Ciano */\n    .menos-vendido {background-color: #6f42c1;} /* Roxo */\n    &lt;/style&gt;\n\"\"\", unsafe_allow_html=True)\n\n# Layout para os cards ocupando toda a largura\ncol1, col2, col3 = st.columns([1, 1, 1])\nwith col1:\n    st.markdown(f'&lt;div class=\"card media\"&gt;Média de Preço: R$ {media_preco:.2f}&lt;/div&gt;', unsafe_allow_html=True)\nwith col2:\n    st.markdown(f'&lt;div class=\"card maximo\"&gt;Preço Mais Alto: R$ {preco_maximo:.2f} ▲&lt;/div&gt;', unsafe_allow_html=True)\nwith col3:\n    st.markdown(f'&lt;div class=\"card minimo\"&gt;Preço Mais Baixo: R$ {preco_minimo:.2f} ▼&lt;/div&gt;', unsafe_allow_html=True)\n\n# Novos cards\ncol4, col5, col6 = st.columns([1, 1, 1])\nwith col4:\n    st.markdown(f'&lt;div class=\"card lucro\"&gt;Custo Total: R$ {custo_total:.2f}&lt;/div&gt;', unsafe_allow_html=True)\nwith col5:\n    st.markdown(f'&lt;div class=\"card mais-vendido\"&gt;Produto Mais Vendido: {produto_mais_vendido}&lt;/div&gt;', unsafe_allow_html=True)\nwith col6:\n    st.markdown(f'&lt;div class=\"card menos-vendido\"&gt;Produto Menos Vendido: {produto_menos_vendido}&lt;/div&gt;', unsafe_allow_html=True)\n\n# Exibir resultados\nst.write(\"Resultados filtrados:\")\nst.dataframe(df_filtrado)\n\n# Gráficos\nst.subheader(\"Distribuição de Preços e Contagem por Classificação\")\n\n# Layout para os gráficos ocupando toda a largura\ncol7, col8 = st.columns([1, 1])\n\nwith col7:\n    st.bar_chart(df_filtrado['preco'], use_container_width=True)\nwith col8:\n    classificacao_contagem = df_filtrado['classificacao'].value_counts()\n    st.bar_chart(classificacao_contagem, use_container_width=True)\n\n# Gráfico de Boxplot\nst.subheader(\"Análise Gráfica\")\nfig_box = px.box(df_filtrado, y='preco', title='Boxplot de Preços')\nst.plotly_chart(fig_box, use_container_width=True)\n\nA criação de um dashboard não só facilita a visualização dos dados, mas também permite a tomada de decisões rápidas e informadas. Assim, os varejistas podem ajustar preços em tempo real com base no desempenho de vendas e na concorrência."
  }
]